# ssk1.py - Simple StateChart Kit, Version 1
#
# Copyright (C) 2007-2013,2018 Matthew R Wette
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the licence with this software.
# If not, see <http://www.gnu.org/licenses/>.

# todo: map full product-state to bitmap for inState function

#__all__ = [ 'StateChart', 'State', 'Region', 'Transition', 'index_ssk' ]

# Notes:
# 1. index attributes are generated by uml2ssk
# 2. id/offset are generated by index_ssk
#
# Todo:
# 1. handle history states: currently added state with special action on trans;
#    should also add entry action to target state

def pp(ind, fmt, *args):
    s = "                           "
    print s[:ind] + fmt % tuple(map(lambda a: str(a), args))

class StateChart:

    def __init__(self):
        self.name = None
        self.root = None                # root state
        self.trans = []                 # set of transitions
        self.maxid = 0                  # max id used
        self.nslot = 0                  # number of slots for sc-state
        self.idmap = []                 # vector of states by (leaf) id

class State:
 
    def __init__(self, parent = None):
        self.parent = parent		# parent region, None if root
        if parent:
            self.level = self.parent.parent.level + 1
        else:
            self.level = 0
        self.name = None		# name for state
        self.region = []		# children, if empty, state is simple
        self.index = None               # index in parent, starts at 0
        self.id = -1                    # unique ID in statechart scope
        self.nslot = 0                  # num slots to store in parent region
        self.offset = -1                # offset in parent region ??
        self.mark = None		# is marked state ('final', 'progress')
        self.a_en = []                  # string[*]: on-entry actions
        self.a_do = []                  # string[*]: during actions(tivities)
        self.a_ex = []                  # string[*]: exit actions
        self.otrans = []                # Transition: outgoing
        self.itrans = []                # Transition: incoming
        self.ltrans = []                # ???: loop transitions (internal)

class Region:

    def __init__(self, parent = None):
        self.parent = parent		# parent state
        self.name = None
        self.state = []			# children, does not include ?hist
        self.initial = 0                # index of initial state
        self.index = None               # index in parent container
        #self.id = -1                    # unique ID in statechart scope
        self.nslot = 0                  # num slots to encode this region
        self.offset = -1                # region offset into encoding
        self.dhist = None               # deep history (name of ix of state)
        self.shist = None               # shallow history (name of ix of state)
        # Non-empty deep hsitory or shallow history means transition
        # out of region must be save state.  So C impl must include struct
        # with saved states

class Transition:

    def __init__(self, type = 'external'):
        self.type = type                # ???
        self.id = -1
        self.source = None		# State: source
        self.target = None		# State: target
        self.label = None		# string: event label
        self.guard = None		# string: guard expression
        self.actions = []		# string: action list


def used_ids(mach):
    "Return list of used (e.g., reserved) IDs."
    def inR(r, l):
        for s in r.state:
            inS(s, l)
    def inS(s, l):
        if len(s.region) == 0:
            if s.id > 0: l.append(s.id)
            return l
        for r in s.region:
           inR(r, l)
        return l
    ids = inS(mach.root, [])
    for id in ids:
        if id > 255:
            print "*** ssk1: reserved ID > 255!  NO NO NO"
    return ids

def assign_leaf_ids(mach, reserved=[]):
    "Assign IDs, leaves first, and return max id."
    def inR(r, mx):
        for s in r.state:
            mx = inS(s, mx)
        return mx
    def inS(s, mx):
        if len(s.region) == 0:
            while True:
                mx = mx + 1
                if mx not in reserved: break
            s.id = mx
            return mx
        for r in s.region:
            mx = inR(r, mx)
        return mx
    return inS(mach.root, 0)

def assign_node_ids(mach, reserved=[]):
    "Assign IDs, leaves first, and return max id."
    def inR(r, mx, res):
        for s in r.state:
            mx = inS(s, mx, res)
        return mx
    def inS(s, mx, res):
        if len(s.region) == 0:
            return mx
        while True:
            mx = mx + 1
            if mx not in res: break
        s.id = mx
        for r in s.region:
            mx = inR(r, mx, res)
        return mx
    mach.maxid = inS(mach.root, 0, reserved)
    return

def gen_idmap(mach):
    "Set up map of id to state."
    def inR(m, r):
        for s in r.state:
            inS(m, s)
    def inS(m, s):
        m.idmap[s.id] = s
        for r in s.region:
            inR(m, r)
    mach.idmap = (mach.maxid+1)*[None]
    inS(mach, mach.root)

def assign_nslots(mach):
    def inR(r):
        nslot = 0
        for s in r.state:
            ns = inS(s)
            if ns > nslot: nslot = ns
        r.nslot = nslot
        return nslot
    def inS(s):
        if len(s.region) == 0:
            s.nslot = 1
            return 1
        nslot = 0
        for r in s.region:
            nslot += inR(r)
        s.nslot = nslot
        return nslot
    mach.nslot = inS(mach.root)
    return
    
def assign_offsets(mach):
    def inR(r, offset):
        r.offset = offset
        for s in r.state:
            inS(s, offset)
        return offset + r.nslot
    def inS(s, offset):
        s.offset = offset
        for r in s.region:
            offset = inR(r, offset)
    inS(mach.root, 0)

def expand_nslots(mach):
    """
    Expand nslot for last region of each state to fill out max for
    the parent state.
    """
    def inR(r):
        for s in r.state:
            s.nslot = r.nslot
            inS(s)
    def inS(s):
        nslot = 0
        for r in s.region:
            nslot += r.nslot
            if r == s.region[-1]:
                if s.nslot > nslot:
                    r.nslot += s.nslot - nslot
            inR(r)
    inS(mach.root)
    return

def cmp_tr(a, b):
    if a.source.id < b.source.id:
        return -1
    elif a.source.id > b.source.id:
        return 1
    elif a.label < b.label:
        return -1
    elif a.label > b.label:
        return 1
    else:
        return 0

def index_ssk(ss):
    print "add depth to SSK regions/states"
    rez = used_ids(ss)
    #print "used_ids => ", rez
    mx = assign_leaf_ids(ss, rez)
    rez.extend(range(1,mx+1))
    mx = assign_node_ids(ss, rez)
    gen_idmap(ss)
    ss.trans.sort(cmp_tr)
    #
    assign_nslots(ss)
    assign_offsets(ss)
    expand_nslots(ss)
    #
    x = 4
    if x == 1:
        esl, esd, trl = buildit(ss)
    if x == 2:
        s1 = elab_state(ss, ss.idmap[9])
        s2 = elab_state(ss, ss.idmap[2])
        pp(0, "9: %s  2: %s", s1, s2)
    if x == 3:
        for t in ss.trans:
            print t.source.id, t.label
    if x == 4:
        print "labels=", mach_labels(ss)

# === new development =================

import pdb

def elab_state(mach, state):
    """
    Elaborate state.
    """
    def inR(region, ste):
        inS(region.state[region.initial], ste)
    def inS(state, ste):
        if len(state.region) == 0:
            inreg = state.parent
            st = inreg.offset
            ns = inreg.nslot
            nd = st + ns
            ste[st:nd] = ns*[0]
            ste[st] = state.id
        else:
            for r in state.region:
                inR(r, ste)
    #
    stenc = mach.nslot*[None]
    inS(state, stenc)
    return tuple(stenc)

def merge_encsts(est0, ests):
    """
    To the encoded state est, merge elaborated states ests as updated states.
    Report failure if state updates are not consistent.
    """
    est1 = list(est0)
    n = len(est0)
    for i in range(n):
        used = False
        for es in ests:
            if es[i] != None:
                if used:
                    raise Exception, "inconsistent targets"
                used = True
                est1[i] = es[i]
    return tuple(est1)

def merge_states(mach, est0, states):
    """
    Given an encoded state and a list of ssk States, generate a new encoded
    state.
    """
    ests = []
    for s in states:
        ests.append(elab_state(mach, s))
    return merge_encsts(est0, ests)

def merge_pstate(est0, pstate):
    """
    This is a hack to replace leaf state in encoded state with parent state.
    It is used for searching for transitions.
    """
    est1 = list(est0)
    st = pstate.offset
    nd = pstate.offset + pstate.nslot
    est1[st:nd] = pstate.nslot*[0]
    est1[st] = pstate.id
    return tuple(est1)

def find_transitions(mach, label):
    #
    pass

def mach_labels(mach):
    """
    Find all labels used in a machine.
    """
    used = set()
    for t in mach.trans:
        if t.label:
            used.add(t.label)
    return list(used)

def state_depth(mach, encst):
    """
    Return the (lowest) state depth.
    """
    ns = len(encst)
    depth = 0
    ix = 0
    while ix < ns:
        if encst[ix] == 0:
            ix += 1
            continue
        st = mach.idmap[encst[ix]]
        if st.level > depth:
            depth = st.level
    return depth

def raise_depth(mach, est0):
    """
    Raise the depth of est0 one level.
    At top est1[0] will be equal to mach.root.id.
    """
    ns = len(est0)
    est1 = list(est0)
    depth = 0
    at_depth = []
    ix = 0
    while ix < ns:
        if est0[ix] == 0:
            ix += 1
            continue
        st = mach.idmap[est0[ix]]
        if st.level > depth:
            depth = st.level
            at_depth = [ix]
        elif st.level == depth:
            at_depth.append(ix)
    return depth

def buildit(mach):
    init = elab_state(mach, mach.root)
    pp(0, "init=%s", init)
    nslot = mach.nslot
    labels = mach_labels(mach)

    # generate transitions from init
    esl = []
    trl = []
    est = tuple(map(lambda e: e or 0, init))
    next = [est]
    while True:
        if len(next) == 0: break
        esl.extend(next)
        prev = next; next = []
        #pp(0, "prev=%s", prev)
        for es in prev:
            ix = 0
            es0 = es
            for label in labels:
                # I think this will work best if we iterate over labels.
                # Then start at es and iterate through levels via raise_depth
                # until returned est[0] == mach.root.id.
                while es0[0] != mach.root.id:

                    # list of transitions from source in es
                    tl = filter(lambda t: \
                                t.source.id in es0 and t.label == label,
                                mach.trans)

                    # collect comb's of encoded targets
                    if len(tl) > 0:
                        pp(2, "multiple transitions:")
                        for t in tl:
                            pp(2, "t [%s %s %s]", tr.source.id, label, \
                               tr.target.id)
                    else:
                        pp(2, "t [%s %s %s]", tr.source.id, label, tr.target.id)

                    # Following part needs work.
                    et = merge_states(mach, es, [tr.target])
                    trl.append([es, tr, et])
                    #pp(4, "merge: %s =%s=> %s", es, tr.label, et)
                    if not et in esl and et not in next:
                        next.append(et)

                # Now propagate each state in es to parent.
                # \todo Do we need to do all combinations here?  
                while ix < nslot:
                    # \todo Fix this hack: idmap[0] should be root
                    #       Should root.id always be 0? (not currently)
                    if es0[ix] == 0:
                        ix = ix + 1
                        continue
                    #
                    s = mach.idmap[es0[ix]]
                    if s.parent.parent != mach.root:
                        es0 = merge_pstate(es0, s.parent.parent)
                        break
                    else:
                        ix = ix + 1
                if ix == nslot:
                    break
    print "esl:", esl
    #print "trl:", trl
    # Generate dict
    esd = {}
    nes = len(esl)
    for i in range(nes):
        esd[esl[i]] = i
    #print "esd:", esd
    trl = map(lambda t: [esd[t[0]], t[1], esd[t[2]]], trl)
    print trl
    return esl, esd, trl

    
# --- last line of ssk1.py ---
